
<?php


/*
There are n observations.  X = { x_1,...,x_n }
Each observation is a d-dimensional vector.

The k-means algorithm attempts to partition these N observations
into k sets, S = {s_1,...,s_k}, k<=n, or clusters such that the 
clusters' means, m_i where 1<=i<=k, on the whole,
provide the smallest total sum-of-squares.

1) A value for k must be chosen
2) Some method must be used to get k different means to start the partitioning process.
	a) The Forgy Method
	
		The Forgy method randomly chooses k obersavtions from the n oberservations
		and uses these as the means for the partitioning process.

3) Assignment step: Assign each observation to the cluster with the closest mean.
					Since  each observation is not necessarily one dimensional
					and not necessarily an integer, some distance function, d(x,m)
					where x is the observation and m is the mean of a cluster,
					must be defined.

4) For each cluster created by the assignment step, a new mean must be found.
	the new mean is found by the sum of the observations in the cluster divided by 
	the number of items in the cluster. Since the observations in the cluster may have
	more than one dimension and they may not all necessarily be integers, it should
	be possible for the user to sepcify a sum function for the integers.

The algorithm should terminate when the clusters generated by the assignment step
are identical to the clusters before the assignment step was reached. If the clusters aren't
identical, the new means should be found and the algorithm should return to the assignment
step.
*/



class KMeansClustering
{


	function __construct()
	{
		//$this->observations_changed = true;
	}

	

	//function setClusterCount
	//Description: used to set how many clusters the observations should be paritioned into.
	//The cluster_count should be an integer, and it should be less than the number of
	//observations ( you can't group m items into n groups, where n > m )
	public function setClusterCount( $cluster_count )
	{
		if( !is_int($cluster_count) || ($cluster_count > $this->observations) ) 
			return false;
		$this->k = $cluster_count;
		return true;
	}


	//function setDistanceFunction
	//Description: used to set the distance function which operates
	//on the observations during the assignment step. More specifically,
	//it's used to find the difference between the observation in question
	//and the mean of a particular cluster.
	public function setDistanceFunction( $distance_func_name )
	{
		if( !function_exists($distance_func_name) ) return false;
		$this->distance_func = $distance_func_name;
		return true;
	}



	//function setMeanFunction
	//Description: used to set the mean function which operates
	//on the observations during the process where the new means
	//are found.
	public function setMeanFunction( $mean_func_name )
	{
		if( !function_exists($mean_func_name) ) return false;
		$this->mean_func = $mean_func_name;
		return true;
	}



	//function setObservations
	//Description: used to set the observations that will be clustered.
	//It's the caller's responsibility to ensure that the $observations array is uniform.
	public function setObservations( array $observations )
	{
		if( !count($observations) ) return false;
		$this->observations = array_values( $observations );
		//$this->observations_changed = true;
		return true;
	}


	//function addObservations
	//Description: used to add observations to the previous array of observations.
	public function addObservations(  array $new_observations )
	{
		if( !count($observations) ) return false;
		if( !isset( $this->observations ) ) $this->setObservations( $new_observations );
		$merged_array = array_merge( $this->observations, $new_observations );
		$this->setObservations( $merged_array );	
		return true;
	}




	public function clusterObservations( $times )
	{

		if( !isset($this->distance_func) || !isset($this->sum_func) ) return false;

		$result = $this->Forgy();
		if( !$result ) return false;
		//Initial K-Means have been set, time to assign observations to clusters

		while( true )
		{
			$new_clusters = array();

			foreach( $this->observations as $observation )
			{
			  $squareDifferences = array();
			  for( $i = 0; $i < $this->k; ++$i )
			  	 $squareDifferences[] = $this->distance_func($observation, $this->k_means[$i] );
			  
			  //Find minimum
			  $lowest = $squareDifferences[0];
			  $cluster_index = 0;	
			  for( $i = 1; $i < $this->k; ++$i )	
			  {
			  	if( $squareDifferences[$i] < $lowest )
			  		{
			  			$lowest = $squareDifferences[$i];
			  			$cluster_index = $i;
			  		}
			  }
			  $new_clusters[$cluster_index][] = $observation;
			}

			//If $new_clusters is identical to the old clusters, then we should terminate the algorithm
			if( isset($this->k_clusters) )
				if( $new_clusters == $this->k_clusters ) break;

			$this->k_clusters = $new_clusters;

			//Clusters have changed, time to find new means

			for( $i = 0; $i < $this->k; ++$i )
			{
				//Find the new mean from each cluster
				$this->k_means[$i] = $this->mean_func( $this->k_clusters[$i] );
			}
		}


		return $this->k_clusters;
	}
	

	//function Forgy
	//Description: used for randomly selecting k observations to be used as means.
	//Note: There is no need to seed the random number generator, this is done
	//automatically in php as of version 4.2.0.
	private function Forgy()
	{
		if( !isset($this->oberservations)  ||
		    !is_array($this->observations) ||
		    !isset($this->k) 
		  )
		   return false;

		//So after I write like 10 lines of code to find k distinct valid
		//array indexes, I read about array_rand..

		$random_indexes = array_rand( $this->observations, $this->k );

		$this->k_means = array();

		//Set initial k-means
		foreach( $random_indexes as $index )
			$this->k_means[] = $this->observations[ $index ];
		
		return true;
	}



	private $distance_func; //function for finding the distance or difference between two observations
	private $mean_func;	//function for finding the mean of a number of observations

	private $observations; //a number of d-dimensional observations, guaranteed to have integer indexes
	private $k; //number of clusters
	private $k_means; //k mean values used in the assignment step
	private $k_clusters; //k clusters of d-dimensional objects

}




//TEST CODE


function r_distance( array $observation1, array $observation2 )
{
  $distance = pow(($observation1[0] - $observation2[0]),2) + pow($observation1[1]-$observation2[1],2) + 
  			  pow(($observation1[2] - $observation2[2]),2);

  return $distance;
 }



function r_mean( array $cluster )
{


	$mean = 0;
	foreach( $cluster as $observation )
	{
		
	}


	return $mean;
}

$observations = array(  array(1,2,3), array(5,6,7), array(11,12,13) );





 ?>